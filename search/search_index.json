{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"My Little C Library # A static ANSI C library gathering things I learned in college. I started to make this lib because, during a C project I was bored to reimplement same data structures over again for different objects. I was convinced there must exist a way to juste simply write generic data structures. But while working on it I realized few things: - Genericity need abstraction. And the more you want to allow users to take distance from the computer implementation the more abstraction you'll need and the bigger the lib will be - leading to much more work. - More abstraction mean lower performance But hey I knew it. Tough it's quite interesting to experiment those limitation with a practical example. Two quotes from computer scientists I read online perfectly illustrate the idea: Any problem in computer science can be solved by adding another layer of abstraction. David Wheeler Any performance problem in computer science can be solved by removing a layer of abstraction. Dave Clark So, I think this lib could be ok to use for small projects or to visualize some data structures while learning C in college, but not when there are strict needs in time performance or memory limitation. Roadmap/todo list # Dashboard Antoine Bastos 2022 - Apache-2.0 licensed","title":"Home"},{"location":"#my-little-c-library","text":"A static ANSI C library gathering things I learned in college. I started to make this lib because, during a C project I was bored to reimplement same data structures over again for different objects. I was convinced there must exist a way to juste simply write generic data structures. But while working on it I realized few things: - Genericity need abstraction. And the more you want to allow users to take distance from the computer implementation the more abstraction you'll need and the bigger the lib will be - leading to much more work. - More abstraction mean lower performance But hey I knew it. Tough it's quite interesting to experiment those limitation with a practical example. Two quotes from computer scientists I read online perfectly illustrate the idea: Any problem in computer science can be solved by adding another layer of abstraction. David Wheeler Any performance problem in computer science can be solved by removing a layer of abstraction. Dave Clark So, I think this lib could be ok to use for small projects or to visualize some data structures while learning C in college, but not when there are strict needs in time performance or memory limitation.","title":"My Little C Library"},{"location":"#roadmaptodo-list","text":"Dashboard Antoine Bastos 2022 - Apache-2.0 licensed","title":"Roadmap/todo list"},{"location":"credits/","text":"For this documentation # Material for MkDocs by Martin Donath Mkdocs-graphviz by Rodrigo Schwencke","title":"Credits"},{"location":"credits/#for-this-documentation","text":"Material for MkDocs by Martin Donath Mkdocs-graphviz by Rodrigo Schwencke","title":"For this documentation"},{"location":"extended-examples/","text":"Movies # See examples/ directory","title":"Extended examples"},{"location":"extended-examples/#movies","text":"See examples/ directory","title":"Movies"},{"location":"implementation/","text":"Introduction # The structures are linked to a type descriptor (called 'td') trough which they use the associated functions, allowing to manipulate the data independently of the effective type they are carrying. You specify the data carried by the structure at creation. For example the linked list is implemented like this . You use the linked list this way: LinkedList * l = new_linked_list ( int_m ); linked_list_append ( l , new_int ( 3 )); As the functions of a structures call other functions through the descriptor, we can override the methods behavior be using custom ones (so, on the modified structure only). void my_custom_fprintf ( const void * data , FILE * stream ){ fprintf ( \"[--- %c ---]\" , * ( char * ) data ); } ... LinkedList * l = new_linked_list ( char_m ); l -> td -> fprint = my_custom_fprintf ; Structures inheritance # flowchart TB ArrayList --> TypeDescriptor LinkedList --> TypeDescriptor DoubleLinkedList --> TypeDescriptor List --> ArrayList List --> LinkedList List --> CircularLinkedList --> LinkedList List --> DoubleLinkedList List --> CircularDoubleLinkedList --> DoubleLinkedList BinaryHeap --> ArrayList Queue --> List Stack --> List BinarySearchTree --> TypeDescriptor TernarySearchTree --> TypeDescriptor AVLTree --> TypeDescriptor BKTree --> TypeDescriptor Linked list implementation # flowchart LR subgraph ll[LinkedList] td head end head --> cell0 td --> tdescriptor subgraph tdescriptor[TypeDescriptor] data_size manifest f0(\"data_free\") f1(\"printf()\") f2(\"fprintf()\") f3(\"cmp()\") f4(\"eq()\") ... end subgraph cell0[LinkedListNode] v0(void *data) next0(next) end next0 --> cell1 subgraph cell1[LinkedListNode] v1(void *data) next1(next) end next1 --> cell2 subgraph cell2[LinkedListNode] v2(void *data) next2(next) end Basically all structures are implemented this way.","title":"Implementation"},{"location":"implementation/#introduction","text":"The structures are linked to a type descriptor (called 'td') trough which they use the associated functions, allowing to manipulate the data independently of the effective type they are carrying. You specify the data carried by the structure at creation. For example the linked list is implemented like this . You use the linked list this way: LinkedList * l = new_linked_list ( int_m ); linked_list_append ( l , new_int ( 3 )); As the functions of a structures call other functions through the descriptor, we can override the methods behavior be using custom ones (so, on the modified structure only). void my_custom_fprintf ( const void * data , FILE * stream ){ fprintf ( \"[--- %c ---]\" , * ( char * ) data ); } ... LinkedList * l = new_linked_list ( char_m ); l -> td -> fprint = my_custom_fprintf ;","title":"Introduction"},{"location":"implementation/#structures-inheritance","text":"flowchart TB ArrayList --> TypeDescriptor LinkedList --> TypeDescriptor DoubleLinkedList --> TypeDescriptor List --> ArrayList List --> LinkedList List --> CircularLinkedList --> LinkedList List --> DoubleLinkedList List --> CircularDoubleLinkedList --> DoubleLinkedList BinaryHeap --> ArrayList Queue --> List Stack --> List BinarySearchTree --> TypeDescriptor TernarySearchTree --> TypeDescriptor AVLTree --> TypeDescriptor BKTree --> TypeDescriptor","title":"Structures inheritance"},{"location":"implementation/#linked-list-implementation","text":"flowchart LR subgraph ll[LinkedList] td head end head --> cell0 td --> tdescriptor subgraph tdescriptor[TypeDescriptor] data_size manifest f0(\"data_free\") f1(\"printf()\") f2(\"fprintf()\") f3(\"cmp()\") f4(\"eq()\") ... end subgraph cell0[LinkedListNode] v0(void *data) next0(next) end next0 --> cell1 subgraph cell1[LinkedListNode] v1(void *data) next1(next) end next1 --> cell2 subgraph cell2[LinkedListNode] v2(void *data) next2(next) end Basically all structures are implemented this way.","title":"Linked list implementation"},{"location":"installation/","text":"link the lib with argument -Lpath -lMLCL where path is the dir where the archive lMLCL.a is stored You can see small examples of use of the lib in examples/","title":"Installation"},{"location":"core/filter/","text":"Comparison predicate # NEQ // not equal != EQ // equal == LT // less than < LE // less equal <= GT // greater than > GE // greater equal >= Filter # Filter * filter = new_filter ( 1 ); filter -> condition [ 0 ] = new_condition ( movie_filter_on_title , new_str ( \"Matrix\" ), EQ , str_free ); filter_free ( & filter ); Evaluate # filter -> evaluate ( filter , mycustomstruct ); Free # filter_free ( & filter ); Make your filter # /** * @brief this is a typical * filter function for a Filter * * @param the struct / data that * will be tested in this filter * * @param field_value a value to * pass to the test (or a more complex structure...) * * @param cmp_predicate NEQ, EQ, LT, LE,... * * @return 1 if not passing the filter, * 0 else (no problem) **/ int movie_filter_title ( void * self , void * field_value , comparison_predicate_t cmp_predicate ){ Movie * movie ; if ( ! self || ! field_value ) return 0 ; movie = ( Movie * ) self ; return logic_cmp ( strcmp ( movie -> title , field_value ), cmp_predicate ); } The function logic_cmp is very important (!!), it's a shortcut to not have to write a switch each time for the predicate. then use this filter function as condition in a Filter instance /* MLCL_Filter.h */ /** * @brief make a new condition from * filter_function for a Filter instance * * @param filter_function a function to check * condition on structure/type with a Filter * * @param value a value to compare the field with * * @param cmp_predicate how to compare * the field with the value * * @param value_free Function to free the given * field_value. Set NULL to avoid freeing * * @return */ ConditionalFilter * new_condition ( cfilter_f filter_function , void * field_value , comparison_predicate_t cmp_predicate , void ( * value_free ) ( void * data ) ); filter = new_filter ( 1 ); /* We want to target movies with title \"Barry Lyndon\" */ filter -> conditions [ 0 ] = new_condition ( movie_filter_title , new_str ( \"Barry Lyndon\" ), EQ , int_free );","title":"Filter"},{"location":"core/filter/#comparison-predicate","text":"NEQ // not equal != EQ // equal == LT // less than < LE // less equal <= GT // greater than > GE // greater equal >=","title":"Comparison predicate"},{"location":"core/filter/#filter","text":"Filter * filter = new_filter ( 1 ); filter -> condition [ 0 ] = new_condition ( movie_filter_on_title , new_str ( \"Matrix\" ), EQ , str_free ); filter_free ( & filter );","title":"Filter"},{"location":"core/filter/#evaluate","text":"filter -> evaluate ( filter , mycustomstruct );","title":"Evaluate"},{"location":"core/filter/#free","text":"filter_free ( & filter );","title":"Free"},{"location":"core/filter/#make-your-filter","text":"/** * @brief this is a typical * filter function for a Filter * * @param the struct / data that * will be tested in this filter * * @param field_value a value to * pass to the test (or a more complex structure...) * * @param cmp_predicate NEQ, EQ, LT, LE,... * * @return 1 if not passing the filter, * 0 else (no problem) **/ int movie_filter_title ( void * self , void * field_value , comparison_predicate_t cmp_predicate ){ Movie * movie ; if ( ! self || ! field_value ) return 0 ; movie = ( Movie * ) self ; return logic_cmp ( strcmp ( movie -> title , field_value ), cmp_predicate ); } The function logic_cmp is very important (!!), it's a shortcut to not have to write a switch each time for the predicate. then use this filter function as condition in a Filter instance /* MLCL_Filter.h */ /** * @brief make a new condition from * filter_function for a Filter instance * * @param filter_function a function to check * condition on structure/type with a Filter * * @param value a value to compare the field with * * @param cmp_predicate how to compare * the field with the value * * @param value_free Function to free the given * field_value. Set NULL to avoid freeing * * @return */ ConditionalFilter * new_condition ( cfilter_f filter_function , void * field_value , comparison_predicate_t cmp_predicate , void ( * value_free ) ( void * data ) ); filter = new_filter ( 1 ); /* We want to target movies with title \"Barry Lyndon\" */ filter -> conditions [ 0 ] = new_condition ( movie_filter_title , new_str ( \"Barry Lyndon\" ), EQ , int_free );","title":"Make your filter"},{"location":"core/types/","text":"Type manifest # What's that # All the structures are linked to a TypeDescriptor , an interface required to manipulate the data they are carrying. It requires (for now), few things: - the size of the type you want to use - some functions to print the data - a function to free the data and another one to copy the data (deep or not, you decide if you make your own) - some comparison functions The TypeDescriptor gets those through a type manifest which handle specific functions of the type to be manipulated. Its like defining you own type in Python (__str__, __eq__, __lt__, etc...). When making new structures you pass the manifest of the type you want them to carry : ArrayList * l = new_array_list ( int_m ); // int_m..anifest (easy to remember because it's also the m of mlcl) Define your own structure/type # Let say you implemented a Movie structure. You can take example on the basic types, and can do as follows: /* Movie.h */ typedef struct { short year ; short minutes ; char * title ; Person * director ; List * cast ; /* a list of Person */ } Movie ; /* ... */ /* Movie.c */ Movie * new_movie ( char * title , short year ){ Movie * movie ; if ( ! title ) return NULL ; movie = ( Movie * ) malloc ( sizeof ( Movie )); movie -> cast = new_list ( ARRAY_LIST , person_m ); if ( ! movie -> cast ){ movie_free ( movie ); return NULL ; } movie -> title = title ; movie -> year = year ; return movie ; } void movie_m ( TypeDescriptor * td ){ assert ( td ); td -> data_size = sizeof ( Movie ); td -> manifest = movie_m ; td -> cmp = movie_cmp ; td -> print = movie_print ; td -> fprint = movie_fprint ; td -> copy = NULL ; td -> data_free = movie_free ; td -> eq = movie_eq ; td -> lt = movie_lt ; td -> le = movie_le ; td -> gt = movie_gt ; td -> ge = movie_ge ; } int movie_cmp ( const void * x , const void * y ){ /* Sorting will be made on title by default */ return strcmp ((( Movie * ) x ) -> title , (( Movie * ) y ) -> title ); } int movie_eq ( const void * x , const void * y ){ return movie_cmp ( x , y ) == 0 ; } int movie_lt ( const void * x , const void * y ){ return movie_cmp ( x , y ) < 0 ; } int movie_le ( const void * x , const void * y ){ return movie_cmp ( x , y ) <= 0 ; } int movie_gt ( const void * x , const void * y ){ return movie_cmp ( x , y ) > 0 ; } int movie_ge ( const void * x , const void * y ){ return movie_cmp ( x , y ) >= 0 ; } void movie_print ( const void * x ){ movie_fprint ( x , stdout ); } void movie_fprint ( const void * x , FILE * stream ){ Movie * movie ; if ( ! x ) return ; movie = ( Movie * ) x ; fprintf ( stream , \"%s (%hd)\" , movie -> title , movie -> year ); } void movie_free ( void * x ){ Movie * movie ; if ( ! x ) return ; movie = ( Movie * ) x ; list_free ( & movie -> cast ); person_free ( movie -> director ); free ( movie -> title ); free ( x ); } /* Related functions of the Movie struct... */ Then you will be able to use the Movie struct in all the data structures. int main (){ LinkedList movies ; l = new_linked_list ( movie_m ); linked_list_prepend ( movies , new_movie ( \"Tron\" , 1982 )); linked_list_prepend ( movies , new_movie ( \"Tron: Legacy\" , 2010 )); linked_list_print ( movies ); /* [Tron legacy, Tron] */ linked_list_free ( & movies ); return 0 ; }","title":"Types"},{"location":"core/types/#type-manifest","text":"","title":"Type manifest"},{"location":"core/types/#whats-that","text":"All the structures are linked to a TypeDescriptor , an interface required to manipulate the data they are carrying. It requires (for now), few things: - the size of the type you want to use - some functions to print the data - a function to free the data and another one to copy the data (deep or not, you decide if you make your own) - some comparison functions The TypeDescriptor gets those through a type manifest which handle specific functions of the type to be manipulated. Its like defining you own type in Python (__str__, __eq__, __lt__, etc...). When making new structures you pass the manifest of the type you want them to carry : ArrayList * l = new_array_list ( int_m ); // int_m..anifest (easy to remember because it's also the m of mlcl)","title":"What's that"},{"location":"core/types/#define-your-own-structuretype","text":"Let say you implemented a Movie structure. You can take example on the basic types, and can do as follows: /* Movie.h */ typedef struct { short year ; short minutes ; char * title ; Person * director ; List * cast ; /* a list of Person */ } Movie ; /* ... */ /* Movie.c */ Movie * new_movie ( char * title , short year ){ Movie * movie ; if ( ! title ) return NULL ; movie = ( Movie * ) malloc ( sizeof ( Movie )); movie -> cast = new_list ( ARRAY_LIST , person_m ); if ( ! movie -> cast ){ movie_free ( movie ); return NULL ; } movie -> title = title ; movie -> year = year ; return movie ; } void movie_m ( TypeDescriptor * td ){ assert ( td ); td -> data_size = sizeof ( Movie ); td -> manifest = movie_m ; td -> cmp = movie_cmp ; td -> print = movie_print ; td -> fprint = movie_fprint ; td -> copy = NULL ; td -> data_free = movie_free ; td -> eq = movie_eq ; td -> lt = movie_lt ; td -> le = movie_le ; td -> gt = movie_gt ; td -> ge = movie_ge ; } int movie_cmp ( const void * x , const void * y ){ /* Sorting will be made on title by default */ return strcmp ((( Movie * ) x ) -> title , (( Movie * ) y ) -> title ); } int movie_eq ( const void * x , const void * y ){ return movie_cmp ( x , y ) == 0 ; } int movie_lt ( const void * x , const void * y ){ return movie_cmp ( x , y ) < 0 ; } int movie_le ( const void * x , const void * y ){ return movie_cmp ( x , y ) <= 0 ; } int movie_gt ( const void * x , const void * y ){ return movie_cmp ( x , y ) > 0 ; } int movie_ge ( const void * x , const void * y ){ return movie_cmp ( x , y ) >= 0 ; } void movie_print ( const void * x ){ movie_fprint ( x , stdout ); } void movie_fprint ( const void * x , FILE * stream ){ Movie * movie ; if ( ! x ) return ; movie = ( Movie * ) x ; fprintf ( stream , \"%s (%hd)\" , movie -> title , movie -> year ); } void movie_free ( void * x ){ Movie * movie ; if ( ! x ) return ; movie = ( Movie * ) x ; list_free ( & movie -> cast ); person_free ( movie -> director ); free ( movie -> title ); free ( x ); } /* Related functions of the Movie struct... */ Then you will be able to use the Movie struct in all the data structures. int main (){ LinkedList movies ; l = new_linked_list ( movie_m ); linked_list_prepend ( movies , new_movie ( \"Tron\" , 1982 )); linked_list_prepend ( movies , new_movie ( \"Tron: Legacy\" , 2010 )); linked_list_print ( movies ); /* [Tron legacy, Tron] */ linked_list_free ( & movies ); return 0 ; }","title":"Define your own structure/type"},{"location":"data-structures/List/","text":"List # The list interface provides basic methods for the different list implementation A circular linked list of strings: List * list = new_list ( LINKED_LIST , str_m ); list_append ( list , new_str ( \"hell\" )); list_append ( list , new_str \"shell\" )); list_append ( list , new_str \"Foo\" )); list_append ( list , new_str \"bar\" )); list_append ( list , new_str \"Bubble\" )); l_free ( & list ); Limitation # Some of the list implementation have specific methods, other don't. So you will have to understand how structs are shaped. For example if you want to benefit of the sorting methods of the ArrayList through the List interface, you would do: list = new_list ( ARRAY_LIST , int_m ); ... array_list_merge_sort ( list -> s . array_list ); You will notice that here we access the ArrayList implementation through the s (for \"structure\") field, depending on the type of implementation we set to create the List .","title":"Index"},{"location":"data-structures/List/#list","text":"The list interface provides basic methods for the different list implementation A circular linked list of strings: List * list = new_list ( LINKED_LIST , str_m ); list_append ( list , new_str ( \"hell\" )); list_append ( list , new_str \"shell\" )); list_append ( list , new_str \"Foo\" )); list_append ( list , new_str \"bar\" )); list_append ( list , new_str \"Bubble\" )); l_free ( & list );","title":"List"},{"location":"data-structures/List/#limitation","text":"Some of the list implementation have specific methods, other don't. So you will have to understand how structs are shaped. For example if you want to benefit of the sorting methods of the ArrayList through the List interface, you would do: list = new_list ( ARRAY_LIST , int_m ); ... array_list_merge_sort ( list -> s . array_list ); You will notice that here we access the ArrayList implementation through the s (for \"structure\") field, depending on the type of implementation we set to create the List .","title":"Limitation"},{"location":"data-structures/List/array-list/","text":"int i ; ArrayList * list = new_array_list ( int_m ); for ( i = 0 ; i < 5 ; i ++ ) array_list_append ( list , new_int ( i )); array_list_free ( & list ); Insertion # Append # array_list_append ( list , new_int ( 5 )); Prepend # array_list_prepend ( list , new_int ( 5 )); Insert # array_list_insert ( list , 2 , new_int ( 5 )); Searching # Search # Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); array_list_search ( list , filter ); Search all # ArrayList * filtered ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); filtered = array_list_search_all ( list , filter ); Extraction # Pop # Remove the value of the tail void * data ; data = array_list_pop ( list ); Pop index # void * data ; data = array_list_pop_i ( list , 5 ); Extract # void * data ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); data = array_list_extract ( list , filter ); Extract all # ArrayList * filtered ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); filtered = array_list_extract_all ( list , filter ); Deletion # Remove # Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); array_list_remove ( list , filter ); Remove all # Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); array_list_remove_all ( list , filter ); Sorting # Bubble sort # array_list_bubble_sort ( list , int_lt ); Insertion sort # array_list_insertion_sort ( list , int_lt ); Selection sort # array_list_selection_sort ( list , int_lt ); Merge sort # array_list_merge_sort ( list , int_lt ); Quick Sort # array_list_quick_sort ( list , int_lt ); Free # Clear # array_list_clear_w ( & list , int_free ); array_list_clear ( & list ); Free # array_list_free_w ( & list , int_free ); array_list_quick_sort ( & list ); To dot # array_list_to_dot ( list , \"arraylist.dot\" ); Visualization dot %3 values 0 1 2 3 4 digraph { node [ shape = record , fontcolor = black , fontsize = 14 , width = 4.75 , fixedsize = true ]; values [ label = \"0 | 1 | 2 | 3 | 4\" ]; }","title":"Array list"},{"location":"data-structures/List/array-list/#insertion","text":"","title":"Insertion"},{"location":"data-structures/List/array-list/#append","text":"array_list_append ( list , new_int ( 5 ));","title":"Append"},{"location":"data-structures/List/array-list/#prepend","text":"array_list_prepend ( list , new_int ( 5 ));","title":"Prepend"},{"location":"data-structures/List/array-list/#insert","text":"array_list_insert ( list , 2 , new_int ( 5 ));","title":"Insert"},{"location":"data-structures/List/array-list/#searching","text":"","title":"Searching"},{"location":"data-structures/List/array-list/#search","text":"Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); array_list_search ( list , filter );","title":"Search"},{"location":"data-structures/List/array-list/#search-all","text":"ArrayList * filtered ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); filtered = array_list_search_all ( list , filter );","title":"Search all"},{"location":"data-structures/List/array-list/#extraction","text":"","title":"Extraction"},{"location":"data-structures/List/array-list/#pop","text":"Remove the value of the tail void * data ; data = array_list_pop ( list );","title":"Pop"},{"location":"data-structures/List/array-list/#pop-index","text":"void * data ; data = array_list_pop_i ( list , 5 );","title":"Pop index"},{"location":"data-structures/List/array-list/#extract","text":"void * data ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); data = array_list_extract ( list , filter );","title":"Extract"},{"location":"data-structures/List/array-list/#extract-all","text":"ArrayList * filtered ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); filtered = array_list_extract_all ( list , filter );","title":"Extract all"},{"location":"data-structures/List/array-list/#deletion","text":"","title":"Deletion"},{"location":"data-structures/List/array-list/#remove","text":"Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); array_list_remove ( list , filter );","title":"Remove"},{"location":"data-structures/List/array-list/#remove-all","text":"Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); array_list_remove_all ( list , filter );","title":"Remove all"},{"location":"data-structures/List/array-list/#sorting","text":"","title":"Sorting"},{"location":"data-structures/List/array-list/#bubble-sort","text":"array_list_bubble_sort ( list , int_lt );","title":"Bubble sort"},{"location":"data-structures/List/array-list/#insertion-sort","text":"array_list_insertion_sort ( list , int_lt );","title":"Insertion sort"},{"location":"data-structures/List/array-list/#selection-sort","text":"array_list_selection_sort ( list , int_lt );","title":"Selection sort"},{"location":"data-structures/List/array-list/#merge-sort","text":"array_list_merge_sort ( list , int_lt );","title":"Merge sort"},{"location":"data-structures/List/array-list/#quick-sort","text":"array_list_quick_sort ( list , int_lt );","title":"Quick Sort"},{"location":"data-structures/List/array-list/#free","text":"","title":"Free"},{"location":"data-structures/List/array-list/#clear","text":"array_list_clear_w ( & list , int_free ); array_list_clear ( & list );","title":"Clear"},{"location":"data-structures/List/array-list/#free_1","text":"array_list_free_w ( & list , int_free ); array_list_quick_sort ( & list );","title":"Free"},{"location":"data-structures/List/array-list/#to-dot","text":"array_list_to_dot ( list , \"arraylist.dot\" ); Visualization dot %3 values 0 1 2 3 4 digraph { node [ shape = record , fontcolor = black , fontsize = 14 , width = 4.75 , fixedsize = true ]; values [ label = \"0 | 1 | 2 | 3 | 4\" ]; }","title":"To dot"},{"location":"data-structures/List/circular-double-linked-list/","text":"Circular double linked list # int i ; CircularDoubleLinkedList * list = new_double_linked_list ( int_m ); for ( i = 0 ; i < 5 ; i ++ ) circular_double_linked_list_append ( list , new_int ( i )); circuluar_double_linked_list_free ( & list ); To dot # circuluar_double_linked_list_to_dot ( list , \"circulardoublelinkedlist.dot\" ); Visualization dot %3 n0x55ff3bbcf360 0 n0x55ff3bbcf3a0 1 n0x55ff3bbcf360->n0x55ff3bbcf3a0 n0x55ff3bbcf460 4 n0x55ff3bbcf360->n0x55ff3bbcf460 n0x55ff3bbcf3a0->n0x55ff3bbcf360 n0x55ff3bbcf3e0 2 n0x55ff3bbcf3a0->n0x55ff3bbcf3e0 n0x55ff3bbcf3e0->n0x55ff3bbcf3a0 n0x55ff3bbcf420 3 n0x55ff3bbcf3e0->n0x55ff3bbcf420 n0x55ff3bbcf420->n0x55ff3bbcf3e0 n0x55ff3bbcf420->n0x55ff3bbcf460 n0x55ff3bbcf460->n0x55ff3bbcf360 n0x55ff3bbcf460->n0x55ff3bbcf420 digraph { rankdir = \"LR\" ; node [ shape = square , height = .1 , rank = same ] n0x55ff3bbcf360 [ label = \"0\" ] n0x55ff3bbcf360 -> n0x55ff3bbcf3a0 n0x55ff3bbcf3a0 -> n0x55ff3bbcf360 n0x55ff3bbcf3a0 [ label = \"1\" ] n0x55ff3bbcf3a0 -> n0x55ff3bbcf3e0 n0x55ff3bbcf3e0 -> n0x55ff3bbcf3a0 n0x55ff3bbcf3e0 [ label = \"2\" ] n0x55ff3bbcf3e0 -> n0x55ff3bbcf420 n0x55ff3bbcf420 -> n0x55ff3bbcf3e0 n0x55ff3bbcf420 [ label = \"3\" ] n0x55ff3bbcf420 -> n0x55ff3bbcf460 n0x55ff3bbcf460 -> n0x55ff3bbcf420 n0x55ff3bbcf460 [ label = \"4\" ] n0x55ff3bbcf460 -> n0x55ff3bbcf360 n0x55ff3bbcf360 -> n0x55ff3bbcf460 }","title":"Circular double linked list"},{"location":"data-structures/List/circular-double-linked-list/#circular-double-linked-list","text":"int i ; CircularDoubleLinkedList * list = new_double_linked_list ( int_m ); for ( i = 0 ; i < 5 ; i ++ ) circular_double_linked_list_append ( list , new_int ( i )); circuluar_double_linked_list_free ( & list );","title":"Circular double linked list"},{"location":"data-structures/List/circular-double-linked-list/#to-dot","text":"circuluar_double_linked_list_to_dot ( list , \"circulardoublelinkedlist.dot\" ); Visualization dot %3 n0x55ff3bbcf360 0 n0x55ff3bbcf3a0 1 n0x55ff3bbcf360->n0x55ff3bbcf3a0 n0x55ff3bbcf460 4 n0x55ff3bbcf360->n0x55ff3bbcf460 n0x55ff3bbcf3a0->n0x55ff3bbcf360 n0x55ff3bbcf3e0 2 n0x55ff3bbcf3a0->n0x55ff3bbcf3e0 n0x55ff3bbcf3e0->n0x55ff3bbcf3a0 n0x55ff3bbcf420 3 n0x55ff3bbcf3e0->n0x55ff3bbcf420 n0x55ff3bbcf420->n0x55ff3bbcf3e0 n0x55ff3bbcf420->n0x55ff3bbcf460 n0x55ff3bbcf460->n0x55ff3bbcf360 n0x55ff3bbcf460->n0x55ff3bbcf420 digraph { rankdir = \"LR\" ; node [ shape = square , height = .1 , rank = same ] n0x55ff3bbcf360 [ label = \"0\" ] n0x55ff3bbcf360 -> n0x55ff3bbcf3a0 n0x55ff3bbcf3a0 -> n0x55ff3bbcf360 n0x55ff3bbcf3a0 [ label = \"1\" ] n0x55ff3bbcf3a0 -> n0x55ff3bbcf3e0 n0x55ff3bbcf3e0 -> n0x55ff3bbcf3a0 n0x55ff3bbcf3e0 [ label = \"2\" ] n0x55ff3bbcf3e0 -> n0x55ff3bbcf420 n0x55ff3bbcf420 -> n0x55ff3bbcf3e0 n0x55ff3bbcf420 [ label = \"3\" ] n0x55ff3bbcf420 -> n0x55ff3bbcf460 n0x55ff3bbcf460 -> n0x55ff3bbcf420 n0x55ff3bbcf460 [ label = \"4\" ] n0x55ff3bbcf460 -> n0x55ff3bbcf360 n0x55ff3bbcf360 -> n0x55ff3bbcf460 }","title":"To dot"},{"location":"data-structures/List/circular-linked-list/","text":"Circular linked list # int i ; CircularLinkedList * list = new_circular_linked_list ( int_m ); for ( i = 0 ; i < 5 ; i ++ ) circular_linked_list_append ( list , new_int ( i )); circular_linked_list_free ( & list ); Insertion # Append # linked_list_append ( l , new_float ( 2.5f )); linked_list_append ( l , new_float ( 1.2f )); /* [2.5, 1.2] */ Prepend # linked_list_prepend ( l , new_float ( 2.5f )); linked_list_prepend ( l , new_float ( 1.2f )); /* [1.2, 2.5] */ Sorting # Merge sort # linked_list_merge_sort ( list , int_lt ); Searching # Search # Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); linked_list_search ( list , filter ); Search all # ArrayList * filtered ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); filtered = linked_list_search_all ( list , filter ); Extraction # Exctract # void * data ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); data = linked_list_extract ( list , filter ); Extract all # ArrayList * filtered ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); filtered = linked_list_extract_all ( list , filter ); Deletion # Remove # Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); linked_list_remove ( list , filter ); Remove all # Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); linked_list_remove_all ( list , filter ); Free # Clear # linked_list_w ( & list , int_free ); linked_list_clear ( & list ); Free # linked_list_free_w ( & list , int_free ); linked_list_quick_sort ( & list ); To dot # linked_list_to_dot ( list , \"linkedlist.dot\" ); To dot # circular_linked_list_to_dot ( list , \"circularlinkedlist.dot\" ); Visualization dot %3 n0x555693692360 0 n0x5556936923a0 1 n0x555693692360->n0x5556936923a0 n0x5556936923e0 2 n0x5556936923a0->n0x5556936923e0 n0x555693692420 3 n0x5556936923e0->n0x555693692420 n0x555693692460 4 n0x555693692420->n0x555693692460 n0x555693692460->n0x555693692360 digraph { rankdir = \"LR\" ; node [ shape = square , height = .1 , rank = same ] n0x555693692360 [ label = \"0\" ] n0x555693692360 -> n0x5556936923a0 n0x5556936923a0 [ label = \"1\" ] n0x5556936923a0 -> n0x5556936923e0 n0x5556936923e0 [ label = \"2\" ] n0x5556936923e0 -> n0x555693692420 n0x555693692420 [ label = \"3\" ] n0x555693692420 -> n0x555693692460 n0x555693692460 [ label = \"4\" ] n0x555693692460 -> n0x555693692360 }","title":"Circular linked list"},{"location":"data-structures/List/circular-linked-list/#circular-linked-list","text":"int i ; CircularLinkedList * list = new_circular_linked_list ( int_m ); for ( i = 0 ; i < 5 ; i ++ ) circular_linked_list_append ( list , new_int ( i )); circular_linked_list_free ( & list );","title":"Circular linked list"},{"location":"data-structures/List/circular-linked-list/#insertion","text":"","title":"Insertion"},{"location":"data-structures/List/circular-linked-list/#append","text":"linked_list_append ( l , new_float ( 2.5f )); linked_list_append ( l , new_float ( 1.2f )); /* [2.5, 1.2] */","title":"Append"},{"location":"data-structures/List/circular-linked-list/#prepend","text":"linked_list_prepend ( l , new_float ( 2.5f )); linked_list_prepend ( l , new_float ( 1.2f )); /* [1.2, 2.5] */","title":"Prepend"},{"location":"data-structures/List/circular-linked-list/#sorting","text":"","title":"Sorting"},{"location":"data-structures/List/circular-linked-list/#merge-sort","text":"linked_list_merge_sort ( list , int_lt );","title":"Merge sort"},{"location":"data-structures/List/circular-linked-list/#searching","text":"","title":"Searching"},{"location":"data-structures/List/circular-linked-list/#search","text":"Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); linked_list_search ( list , filter );","title":"Search"},{"location":"data-structures/List/circular-linked-list/#search-all","text":"ArrayList * filtered ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); filtered = linked_list_search_all ( list , filter );","title":"Search all"},{"location":"data-structures/List/circular-linked-list/#extraction","text":"","title":"Extraction"},{"location":"data-structures/List/circular-linked-list/#exctract","text":"void * data ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); data = linked_list_extract ( list , filter );","title":"Exctract"},{"location":"data-structures/List/circular-linked-list/#extract-all","text":"ArrayList * filtered ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); filtered = linked_list_extract_all ( list , filter );","title":"Extract all"},{"location":"data-structures/List/circular-linked-list/#deletion","text":"","title":"Deletion"},{"location":"data-structures/List/circular-linked-list/#remove","text":"Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); linked_list_remove ( list , filter );","title":"Remove"},{"location":"data-structures/List/circular-linked-list/#remove-all","text":"Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); linked_list_remove_all ( list , filter );","title":"Remove all"},{"location":"data-structures/List/circular-linked-list/#free","text":"","title":"Free"},{"location":"data-structures/List/circular-linked-list/#clear","text":"linked_list_w ( & list , int_free ); linked_list_clear ( & list );","title":"Clear"},{"location":"data-structures/List/circular-linked-list/#free_1","text":"linked_list_free_w ( & list , int_free ); linked_list_quick_sort ( & list );","title":"Free"},{"location":"data-structures/List/circular-linked-list/#to-dot","text":"linked_list_to_dot ( list , \"linkedlist.dot\" );","title":"To dot"},{"location":"data-structures/List/circular-linked-list/#to-dot_1","text":"circular_linked_list_to_dot ( list , \"circularlinkedlist.dot\" ); Visualization dot %3 n0x555693692360 0 n0x5556936923a0 1 n0x555693692360->n0x5556936923a0 n0x5556936923e0 2 n0x5556936923a0->n0x5556936923e0 n0x555693692420 3 n0x5556936923e0->n0x555693692420 n0x555693692460 4 n0x555693692420->n0x555693692460 n0x555693692460->n0x555693692360 digraph { rankdir = \"LR\" ; node [ shape = square , height = .1 , rank = same ] n0x555693692360 [ label = \"0\" ] n0x555693692360 -> n0x5556936923a0 n0x5556936923a0 [ label = \"1\" ] n0x5556936923a0 -> n0x5556936923e0 n0x5556936923e0 [ label = \"2\" ] n0x5556936923e0 -> n0x555693692420 n0x555693692420 [ label = \"3\" ] n0x555693692420 -> n0x555693692460 n0x555693692460 [ label = \"4\" ] n0x555693692460 -> n0x555693692360 }","title":"To dot"},{"location":"data-structures/List/double-linked-list/","text":"Double linked list # int i ; DoubleLinkedList * list = new_double_linked_list ( int_m ); for ( i = 0 ; i < 5 ; i ++ ) double_linked_list_append ( list , new_int ( i )); double_linked_list_free ( & list ); To dot # double_linked_list_to_dot ( list , \"doublelinkedlist.dot\" ); Visualization dot %3 n0x5634bd90c360 0 n0x5634bd90c3a0 1 n0x5634bd90c360->n0x5634bd90c3a0 n0x5634bd90c3a0->n0x5634bd90c360 n0x5634bd90c3e0 2 n0x5634bd90c3a0->n0x5634bd90c3e0 n0x5634bd90c3e0->n0x5634bd90c3a0 n0x5634bd90c420 3 n0x5634bd90c3e0->n0x5634bd90c420 n0x5634bd90c420->n0x5634bd90c3e0 n0x5634bd90c460 4 n0x5634bd90c420->n0x5634bd90c460 n0x5634bd90c460->n0x5634bd90c420 digraph { rankdir = \"LR\" ; splines = ortho ; node [ shape = square , height = .1 , rank = same ] n0x5634bd90c360 [ label = \"0\" ] n0x5634bd90c360 -> n0x5634bd90c3a0 n0x5634bd90c3a0 -> n0x5634bd90c360 n0x5634bd90c3a0 [ label = \"1\" ] n0x5634bd90c3a0 -> n0x5634bd90c3e0 n0x5634bd90c3e0 -> n0x5634bd90c3a0 n0x5634bd90c3e0 [ label = \"2\" ] n0x5634bd90c3e0 -> n0x5634bd90c420 n0x5634bd90c420 -> n0x5634bd90c3e0 n0x5634bd90c420 [ label = \"3\" ] n0x5634bd90c420 -> n0x5634bd90c460 n0x5634bd90c460 -> n0x5634bd90c420 n0x5634bd90c460 [ label = \"4\" ] }","title":"Double linked list"},{"location":"data-structures/List/double-linked-list/#double-linked-list","text":"int i ; DoubleLinkedList * list = new_double_linked_list ( int_m ); for ( i = 0 ; i < 5 ; i ++ ) double_linked_list_append ( list , new_int ( i )); double_linked_list_free ( & list );","title":"Double linked list"},{"location":"data-structures/List/double-linked-list/#to-dot","text":"double_linked_list_to_dot ( list , \"doublelinkedlist.dot\" ); Visualization dot %3 n0x5634bd90c360 0 n0x5634bd90c3a0 1 n0x5634bd90c360->n0x5634bd90c3a0 n0x5634bd90c3a0->n0x5634bd90c360 n0x5634bd90c3e0 2 n0x5634bd90c3a0->n0x5634bd90c3e0 n0x5634bd90c3e0->n0x5634bd90c3a0 n0x5634bd90c420 3 n0x5634bd90c3e0->n0x5634bd90c420 n0x5634bd90c420->n0x5634bd90c3e0 n0x5634bd90c460 4 n0x5634bd90c420->n0x5634bd90c460 n0x5634bd90c460->n0x5634bd90c420 digraph { rankdir = \"LR\" ; splines = ortho ; node [ shape = square , height = .1 , rank = same ] n0x5634bd90c360 [ label = \"0\" ] n0x5634bd90c360 -> n0x5634bd90c3a0 n0x5634bd90c3a0 -> n0x5634bd90c360 n0x5634bd90c3a0 [ label = \"1\" ] n0x5634bd90c3a0 -> n0x5634bd90c3e0 n0x5634bd90c3e0 -> n0x5634bd90c3a0 n0x5634bd90c3e0 [ label = \"2\" ] n0x5634bd90c3e0 -> n0x5634bd90c420 n0x5634bd90c420 -> n0x5634bd90c3e0 n0x5634bd90c420 [ label = \"3\" ] n0x5634bd90c420 -> n0x5634bd90c460 n0x5634bd90c460 -> n0x5634bd90c420 n0x5634bd90c460 [ label = \"4\" ] }","title":"To dot"},{"location":"data-structures/List/linked-list/","text":"CircularLinkedList * list = new_circular_linked_list ( float_m ); circular_linked_list_append ( list , new_float ( 1.2f )); circular_linked_list_append ( list , new_float ( 2.5f )); circular_linked_list_append ( list , new_float ( 3.8f )); circular_linked_list_free ( & list ); Insertion # Append # circular_linked_list_append ( l , new_float ( 2.5f )); circular_linked_list_append ( l , new_float ( 1.2f )); /* [2.5, 1.2] */ Prepend # circular_linked_list_prepend ( l , new_float ( 2.5f )); circular_linked_list_prepend ( l , new_float ( 1.2f )); /* [1.2, 2.5] */ Searching # Search # Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); circular_linked_list_search ( list , filter ); Search all # ArrayList * filtered ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); filtered = circular_linked_list_search_all ( list , filter ); Extraction # Pop # circular_linked_list_pop ( l ); Shift # circular_linked_list_shift ( l ); Exctract # void * data ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); data = circular_linked_list_extract ( list , filter ); Extract all # ArrayList * filtered ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); filtered = circular_linked_list_extract_all ( list , filter ); Deletion # Remove # Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); circular_linked_list_remove ( list , filter ); Remove all # Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); circular_linked_list_remove_all ( list , filter ); Free # Clear # circular_linked_list_w ( & list , int_free ); circular_linked_list_clear ( & list ); Free # circular_linked_list_free_w ( & list , int_free ); circular_linked_list_quick_sort ( & list ); To dot # circular_linked_list_to_dot ( list , \"linkedlist.dot\" ); Visualization dot %3 n0x556fa1c6a360 1.20 n0x556fa1c6a3a0 2.50 n0x556fa1c6a360->n0x556fa1c6a3a0 n0x556fa1c6a3e0 3.80 n0x556fa1c6a3a0->n0x556fa1c6a3e0 digraph { rankdir = \"LR\" ; splines = ortho ; node [ shape = square , height = .1 , rank = same ] n0x556fa1c6a360 [ label = \"1.20\" color = \"#000000\" ] n0x556fa1c6a360 -> n0x556fa1c6a3a0 n0x556fa1c6a3a0 [ label = \"2.50\" color = \"#000000\" ] n0x556fa1c6a3a0 -> n0x556fa1c6a3e0 n0x556fa1c6a3e0 [ label = \"3.80\" color = \"#000000\" ] }","title":"Linked list"},{"location":"data-structures/List/linked-list/#insertion","text":"","title":"Insertion"},{"location":"data-structures/List/linked-list/#append","text":"circular_linked_list_append ( l , new_float ( 2.5f )); circular_linked_list_append ( l , new_float ( 1.2f )); /* [2.5, 1.2] */","title":"Append"},{"location":"data-structures/List/linked-list/#prepend","text":"circular_linked_list_prepend ( l , new_float ( 2.5f )); circular_linked_list_prepend ( l , new_float ( 1.2f )); /* [1.2, 2.5] */","title":"Prepend"},{"location":"data-structures/List/linked-list/#searching","text":"","title":"Searching"},{"location":"data-structures/List/linked-list/#search","text":"Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); circular_linked_list_search ( list , filter );","title":"Search"},{"location":"data-structures/List/linked-list/#search-all","text":"ArrayList * filtered ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); filtered = circular_linked_list_search_all ( list , filter );","title":"Search all"},{"location":"data-structures/List/linked-list/#extraction","text":"","title":"Extraction"},{"location":"data-structures/List/linked-list/#pop","text":"circular_linked_list_pop ( l );","title":"Pop"},{"location":"data-structures/List/linked-list/#shift","text":"circular_linked_list_shift ( l );","title":"Shift"},{"location":"data-structures/List/linked-list/#exctract","text":"void * data ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); data = circular_linked_list_extract ( list , filter );","title":"Exctract"},{"location":"data-structures/List/linked-list/#extract-all","text":"ArrayList * filtered ; Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); filtered = circular_linked_list_extract_all ( list , filter );","title":"Extract all"},{"location":"data-structures/List/linked-list/#deletion","text":"","title":"Deletion"},{"location":"data-structures/List/linked-list/#remove","text":"Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); circular_linked_list_remove ( list , filter );","title":"Remove"},{"location":"data-structures/List/linked-list/#remove-all","text":"Filter * filter = new_filter ( 1 ); filter -> conditions [ 0 ] = new_condition ( int_filter , new_int ( 5 ), EQ , int_free ); circular_linked_list_remove_all ( list , filter );","title":"Remove all"},{"location":"data-structures/List/linked-list/#free","text":"","title":"Free"},{"location":"data-structures/List/linked-list/#clear","text":"circular_linked_list_w ( & list , int_free ); circular_linked_list_clear ( & list );","title":"Clear"},{"location":"data-structures/List/linked-list/#free_1","text":"circular_linked_list_free_w ( & list , int_free ); circular_linked_list_quick_sort ( & list );","title":"Free"},{"location":"data-structures/List/linked-list/#to-dot","text":"circular_linked_list_to_dot ( list , \"linkedlist.dot\" ); Visualization dot %3 n0x556fa1c6a360 1.20 n0x556fa1c6a3a0 2.50 n0x556fa1c6a360->n0x556fa1c6a3a0 n0x556fa1c6a3e0 3.80 n0x556fa1c6a3a0->n0x556fa1c6a3e0 digraph { rankdir = \"LR\" ; splines = ortho ; node [ shape = square , height = .1 , rank = same ] n0x556fa1c6a360 [ label = \"1.20\" color = \"#000000\" ] n0x556fa1c6a360 -> n0x556fa1c6a3a0 n0x556fa1c6a3a0 [ label = \"2.50\" color = \"#000000\" ] n0x556fa1c6a3a0 -> n0x556fa1c6a3e0 n0x556fa1c6a3e0 [ label = \"3.80\" color = \"#000000\" ] }","title":"To dot"},{"location":"data-structures/Tree/","text":"to do #","title":"to do"},{"location":"data-structures/Tree/#to-do","text":"","title":"to do"},{"location":"data-structures/Tree/avl-tree/","text":"AVL tree # AVLTree * tree = new_avl_tree ( int_m ); avl_tree_add ( tree , new_int ( 6 )); avl_tree_add ( tree , new_int ( 8 )); avl_tree_add ( tree , new_int ( 1 )); avl_tree_add ( tree , new_int ( 3 )); avl_tree_add ( tree , new_int ( 2 )); avl_tree_free ( & tree ); To dot # avl_tree_to_dot ( tree , \"avltree.dot\" ); Visualization dot tree n0x55f759a67350 6 n0x55f759a67490 2 n0x55f759a67350:c->n0x55f759a67490:valeur n0x55f759a673a0 8 n0x55f759a67350:c->n0x55f759a673a0:valeur n0x55f759a673f0 1 n0x55f759a67490:c->n0x55f759a673f0:valeur n0x55f759a67440 3 n0x55f759a67490:c->n0x55f759a67440:valeur digraph tree { node [ shape = record , height = .1 ] edge [ tailclip = false , arrowtail = dot , dir = both ]; n0x55f759a67350 [ label = \"<left> | <value> 6 | <right>\" ] n0x55f759a67350 : left : c -> n0x55f759a67490 : valeur [ color = red ]; n0x55f759a67490 [ label = \"<left> | <value> 2 | <right>\" ] n0x55f759a67490 : left : c -> n0x55f759a673f0 : valeur [ color = red ]; n0x55f759a673f0 [ label = \"<left> | <value> 1 | <right>\" ] n0x55f759a67490 : right : c -> n0x55f759a67440 : valeur [ color = blue ]; n0x55f759a67440 [ label = \"<left> | <value> 3 | <right>\" ] n0x55f759a67350 : right : c -> n0x55f759a673a0 : valeur [ color = blue ]; n0x55f759a673a0 [ label = \"<left> | <value> 8 | <right>\" ] }","title":"AVL Tree"},{"location":"data-structures/Tree/avl-tree/#avl-tree","text":"AVLTree * tree = new_avl_tree ( int_m ); avl_tree_add ( tree , new_int ( 6 )); avl_tree_add ( tree , new_int ( 8 )); avl_tree_add ( tree , new_int ( 1 )); avl_tree_add ( tree , new_int ( 3 )); avl_tree_add ( tree , new_int ( 2 )); avl_tree_free ( & tree );","title":"AVL tree"},{"location":"data-structures/Tree/avl-tree/#to-dot","text":"avl_tree_to_dot ( tree , \"avltree.dot\" ); Visualization dot tree n0x55f759a67350 6 n0x55f759a67490 2 n0x55f759a67350:c->n0x55f759a67490:valeur n0x55f759a673a0 8 n0x55f759a67350:c->n0x55f759a673a0:valeur n0x55f759a673f0 1 n0x55f759a67490:c->n0x55f759a673f0:valeur n0x55f759a67440 3 n0x55f759a67490:c->n0x55f759a67440:valeur digraph tree { node [ shape = record , height = .1 ] edge [ tailclip = false , arrowtail = dot , dir = both ]; n0x55f759a67350 [ label = \"<left> | <value> 6 | <right>\" ] n0x55f759a67350 : left : c -> n0x55f759a67490 : valeur [ color = red ]; n0x55f759a67490 [ label = \"<left> | <value> 2 | <right>\" ] n0x55f759a67490 : left : c -> n0x55f759a673f0 : valeur [ color = red ]; n0x55f759a673f0 [ label = \"<left> | <value> 1 | <right>\" ] n0x55f759a67490 : right : c -> n0x55f759a67440 : valeur [ color = blue ]; n0x55f759a67440 [ label = \"<left> | <value> 3 | <right>\" ] n0x55f759a67350 : right : c -> n0x55f759a673a0 : valeur [ color = blue ]; n0x55f759a673a0 [ label = \"<left> | <value> 8 | <right>\" ] }","title":"To dot"},{"location":"data-structures/Tree/binary-search-tree/","text":"Binary search tree # BinarySearchTree * tree = new_binary_search_tree ( int_m ); binary_search_tree_add ( tree , new_int ( 6 )); binary_search_tree_add ( tree , new_int ( 8 )); binary_search_tree_add ( tree , new_int ( 1 )); binary_search_tree_add ( tree , new_int ( 3 )); binary_search_tree_add ( tree , new_int ( 2 )); binary_search_tree_free ( & tree ); To dot # binary_search_tree_to_dot ( tree , \"bst.dot\" ); Visualization dot tree n0x55a7757fd350 6 n0x55a7757fd3d0 1 n0x55a7757fd350:c->n0x55a7757fd3d0:valeur n0x55a7757fd390 8 n0x55a7757fd350:c->n0x55a7757fd390:valeur n0x55a7757fd410 3 n0x55a7757fd3d0:c->n0x55a7757fd410:valeur n0x55a7757fd450 2 n0x55a7757fd410:c->n0x55a7757fd450:valeur digraph tree { node [ shape = record , height = .1 ] edge [ tailclip = false , arrowtail = dot , dir = both ]; n0x55a7757fd350 [ label = \"<left> | <value> 6 | <right>\" ] n0x55a7757fd350 : left : c -> n0x55a7757fd3d0 : valeur [ color = red ]; n0x55a7757fd3d0 [ label = \"<left> | <value> 1 | <right>\" ] n0x55a7757fd3d0 : right : c -> n0x55a7757fd410 : valeur [ color = blue ]; n0x55a7757fd410 [ label = \"<left> | <value> 3 | <right>\" ] n0x55a7757fd410 : left : c -> n0x55a7757fd450 : valeur [ color = red ]; n0x55a7757fd450 [ label = \"<left> | <value> 2 | <right>\" ] n0x55a7757fd350 : right : c -> n0x55a7757fd390 : valeur [ color = blue ]; n0x55a7757fd390 [ label = \"<left> | <value> 8 | <right>\" ] }","title":"Binary search tree"},{"location":"data-structures/Tree/binary-search-tree/#binary-search-tree","text":"BinarySearchTree * tree = new_binary_search_tree ( int_m ); binary_search_tree_add ( tree , new_int ( 6 )); binary_search_tree_add ( tree , new_int ( 8 )); binary_search_tree_add ( tree , new_int ( 1 )); binary_search_tree_add ( tree , new_int ( 3 )); binary_search_tree_add ( tree , new_int ( 2 )); binary_search_tree_free ( & tree );","title":"Binary search tree"},{"location":"data-structures/Tree/binary-search-tree/#to-dot","text":"binary_search_tree_to_dot ( tree , \"bst.dot\" ); Visualization dot tree n0x55a7757fd350 6 n0x55a7757fd3d0 1 n0x55a7757fd350:c->n0x55a7757fd3d0:valeur n0x55a7757fd390 8 n0x55a7757fd350:c->n0x55a7757fd390:valeur n0x55a7757fd410 3 n0x55a7757fd3d0:c->n0x55a7757fd410:valeur n0x55a7757fd450 2 n0x55a7757fd410:c->n0x55a7757fd450:valeur digraph tree { node [ shape = record , height = .1 ] edge [ tailclip = false , arrowtail = dot , dir = both ]; n0x55a7757fd350 [ label = \"<left> | <value> 6 | <right>\" ] n0x55a7757fd350 : left : c -> n0x55a7757fd3d0 : valeur [ color = red ]; n0x55a7757fd3d0 [ label = \"<left> | <value> 1 | <right>\" ] n0x55a7757fd3d0 : right : c -> n0x55a7757fd410 : valeur [ color = blue ]; n0x55a7757fd410 [ label = \"<left> | <value> 3 | <right>\" ] n0x55a7757fd410 : left : c -> n0x55a7757fd450 : valeur [ color = red ]; n0x55a7757fd450 [ label = \"<left> | <value> 2 | <right>\" ] n0x55a7757fd350 : right : c -> n0x55a7757fd390 : valeur [ color = blue ]; n0x55a7757fd390 [ label = \"<left> | <value> 8 | <right>\" ] }","title":"To dot"},{"location":"data-structures/Tree/bk-tree/","text":"BK Tree # BKTree * tree = new_bk_tree (); bk_tree_add ( tree , \"Foo\" ); bk_tree_add ( tree , \"Bar\" ); bk_tree_add ( tree , \"Fool\" ); bk_tree_add ( tree , \"Fox\" ); bk_tree_free ( & tree ); Fuzzy search # To dot # bk_tree_to_dot ( list , \"bktree.dot\" ); Visualization dot tree n0x55a93b7d2350 Foo n0x55a93b7d23a0 Bar n0x55a93b7d2350->n0x55a93b7d23a0 3 n0x55a93b7d23d0 Fool n0x55a93b7d2350->n0x55a93b7d23d0 1 n0x55a93b7d2480 Fox n0x55a93b7d23d0->n0x55a93b7d2480 2 digraph tree { n0x55a93b7d2350 [ label = \"Foo\" ] n0x55a93b7d2350 -> n0x55a93b7d23a0 [ color = \"#2257ab\" , label = \" 3 \" ] n0x55a93b7d23a0 [ label = \"Bar\" ] n0x55a93b7d23d0 [ label = \"Fool\" ] n0x55a93b7d2350 -> n0x55a93b7d23d0 [ color = \"#2257ab\" , label = \" 1 \" ] n0x55a93b7d23d0 [ label = \"Fool\" ] n0x55a93b7d23d0 -> n0x55a93b7d2480 [ color = \"#2257ab\" , label = \" 2 \" ] n0x55a93b7d2480 [ label = \"Fox\" ] }","title":"BK Tree"},{"location":"data-structures/Tree/bk-tree/#bk-tree","text":"BKTree * tree = new_bk_tree (); bk_tree_add ( tree , \"Foo\" ); bk_tree_add ( tree , \"Bar\" ); bk_tree_add ( tree , \"Fool\" ); bk_tree_add ( tree , \"Fox\" ); bk_tree_free ( & tree );","title":"BK Tree"},{"location":"data-structures/Tree/bk-tree/#fuzzy-search","text":"","title":"Fuzzy search"},{"location":"data-structures/Tree/bk-tree/#to-dot","text":"bk_tree_to_dot ( list , \"bktree.dot\" ); Visualization dot tree n0x55a93b7d2350 Foo n0x55a93b7d23a0 Bar n0x55a93b7d2350->n0x55a93b7d23a0 3 n0x55a93b7d23d0 Fool n0x55a93b7d2350->n0x55a93b7d23d0 1 n0x55a93b7d2480 Fox n0x55a93b7d23d0->n0x55a93b7d2480 2 digraph tree { n0x55a93b7d2350 [ label = \"Foo\" ] n0x55a93b7d2350 -> n0x55a93b7d23a0 [ color = \"#2257ab\" , label = \" 3 \" ] n0x55a93b7d23a0 [ label = \"Bar\" ] n0x55a93b7d23d0 [ label = \"Fool\" ] n0x55a93b7d2350 -> n0x55a93b7d23d0 [ color = \"#2257ab\" , label = \" 1 \" ] n0x55a93b7d23d0 [ label = \"Fool\" ] n0x55a93b7d23d0 -> n0x55a93b7d2480 [ color = \"#2257ab\" , label = \" 2 \" ] n0x55a93b7d2480 [ label = \"Fox\" ] }","title":"To dot"},{"location":"data-structures/Tree/ternary-search-tree/","text":"Ternary Search Tree (Lexical Tree) # TernarySearchTree * tree = new_ternary_search_tree (); ternary_search_tree_add ( tree , \"Foo\" ); ternary_search_tree_add ( tree , \"Bar\" ); ternary_search_tree_add ( tree , \"Fool\" ); ternary_search_tree_free ( & tree ); To dot # ternary_search_tree_to_dot ( list , \"tst.dot\" ); Visualization dot tree n0x55f181e2ed60 F n0x55f181e2ebc0 B n0x55f181e2ed60:w->n0x55f181e2ebc0:c n0x55f181e2e750 o n0x55f181e2ed60:s->n0x55f181e2e750:c n0x55f181e2ee30 a n0x55f181e2ebc0:s->n0x55f181e2ee30:c n0x55f181e2ee60 r n0x55f181e2ee30:s->n0x55f181e2ee60:c n0x55f181e2ee90 0 n0x55f181e2ee60:s->n0x55f181e2ee90:c n0x55f181e2ed90 o n0x55f181e2e750:s->n0x55f181e2ed90:c n0x55f181e2ed30 0 n0x55f181e2ed90:s->n0x55f181e2ed30:c n0x55f181e2eec0 l n0x55f181e2ed30:e->n0x55f181e2eec0:c n0x55f181e2eef0 0 n0x55f181e2eec0:s->n0x55f181e2eef0:c digraph tree { graph [ splines=true] node [shape=circle,height=.1] n0x55f181e2ed60 [label=\"F\"] n0x55f181e2ed60:w -> n0x55f181e2ebc0:c [color=\"#ab2222\"] n0x55f181e2ebc0 [label=\"B\"] n0x55f181e2ebc0:s -> n0x55f181e2ee30:c n0x55f181e2ee30 [label=\"a\"] n0x55f181e2ee30:s -> n0x55f181e2ee60:c n0x55f181e2ee60 [label=\"r\"] n0x55f181e2ee60:s -> n0x55f181e2ee90:c n0x55f181e2ee90 [label=\"0\"] n0x55f181e2ed60:s -> n0x55f181e2e750:c n0x55f181e2e750 [label=\"o\"] n0x55f181e2e750:s -> n0x55f181e2ed90:c n0x55f181e2ed90 [label=\"o\"] n0x55f181e2ed90:s -> n0x55f181e2ed30:c n0x55f181e2ed30 [label=\"0\"] n0x55f181e2ed30:e -> n0x55f181e2eec0:c [color=\"#2257ab\"] n0x55f181e2eec0 [label=\"l\"] n0x55f181e2eec0:s -> n0x55f181e2eef0:c n0x55f181e2eef0 [label=\"0\"] }","title":"Ternary search tree"},{"location":"data-structures/Tree/ternary-search-tree/#ternary-search-tree-lexical-tree","text":"TernarySearchTree * tree = new_ternary_search_tree (); ternary_search_tree_add ( tree , \"Foo\" ); ternary_search_tree_add ( tree , \"Bar\" ); ternary_search_tree_add ( tree , \"Fool\" ); ternary_search_tree_free ( & tree );","title":"Ternary Search Tree (Lexical Tree)"},{"location":"data-structures/Tree/ternary-search-tree/#to-dot","text":"ternary_search_tree_to_dot ( list , \"tst.dot\" ); Visualization dot tree n0x55f181e2ed60 F n0x55f181e2ebc0 B n0x55f181e2ed60:w->n0x55f181e2ebc0:c n0x55f181e2e750 o n0x55f181e2ed60:s->n0x55f181e2e750:c n0x55f181e2ee30 a n0x55f181e2ebc0:s->n0x55f181e2ee30:c n0x55f181e2ee60 r n0x55f181e2ee30:s->n0x55f181e2ee60:c n0x55f181e2ee90 0 n0x55f181e2ee60:s->n0x55f181e2ee90:c n0x55f181e2ed90 o n0x55f181e2e750:s->n0x55f181e2ed90:c n0x55f181e2ed30 0 n0x55f181e2ed90:s->n0x55f181e2ed30:c n0x55f181e2eec0 l n0x55f181e2ed30:e->n0x55f181e2eec0:c n0x55f181e2eef0 0 n0x55f181e2eec0:s->n0x55f181e2eef0:c digraph tree { graph [ splines=true] node [shape=circle,height=.1] n0x55f181e2ed60 [label=\"F\"] n0x55f181e2ed60:w -> n0x55f181e2ebc0:c [color=\"#ab2222\"] n0x55f181e2ebc0 [label=\"B\"] n0x55f181e2ebc0:s -> n0x55f181e2ee30:c n0x55f181e2ee30 [label=\"a\"] n0x55f181e2ee30:s -> n0x55f181e2ee60:c n0x55f181e2ee60 [label=\"r\"] n0x55f181e2ee60:s -> n0x55f181e2ee90:c n0x55f181e2ee90 [label=\"0\"] n0x55f181e2ed60:s -> n0x55f181e2e750:c n0x55f181e2e750 [label=\"o\"] n0x55f181e2e750:s -> n0x55f181e2ed90:c n0x55f181e2ed90 [label=\"o\"] n0x55f181e2ed90:s -> n0x55f181e2ed30:c n0x55f181e2ed30 [label=\"0\"] n0x55f181e2ed30:e -> n0x55f181e2eec0:c [color=\"#2257ab\"] n0x55f181e2eec0 [label=\"l\"] n0x55f181e2eec0:s -> n0x55f181e2eef0:c n0x55f181e2eef0 [label=\"0\"] }","title":"To dot"},{"location":"util/time/timer/","text":"Timer * new_timer (); Start # void timer_start ( Timer * t ); Update # void timer_update ( Timer * t ); Get delta # int timer_get_delta ( const Timer * t ); Print # void timer_fprint ( const Timer * t , FILE * stream ); void timer_print ( const Timer * t );","title":"Timer"},{"location":"util/time/timer/#start","text":"void timer_start ( Timer * t );","title":"Start"},{"location":"util/time/timer/#update","text":"void timer_update ( Timer * t );","title":"Update"},{"location":"util/time/timer/#get-delta","text":"int timer_get_delta ( const Timer * t );","title":"Get delta"},{"location":"util/time/timer/#print","text":"void timer_fprint ( const Timer * t , FILE * stream ); void timer_print ( const Timer * t );","title":"Print"}]}